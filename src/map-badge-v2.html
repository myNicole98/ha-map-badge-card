<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/7.2.96/css/materialdesignicons.min.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style id="dynamic-styles">
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; overflow: hidden; }
    #map { width: 100%; height: 100vh; }

    .custom-marker-wrapper {
      position: relative;
      width: 48px;
      height: 62px; /* Increased to accommodate pointer shape */
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .custom-marker-position-circle {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      z-index: 1;
    }

    .custom-marker-profile-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 48px;
      height: 54px;
      z-index: 2;
    }

    .custom-marker-image-container {
      width: 48px;
      height: 54px;
      position: relative;
    }

    .custom-marker-image-container::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid var(--border-color, #757575);
      z-index: 1;
    }

    .custom-marker-image {
      width: 48px;
      height: 48px;
      object-fit: cover;
      display: block;
    }

    .custom-marker-badge {
      position: absolute;
      right: -2px;
      bottom: -2px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      z-index: 3;
    }

    #refresh-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #refresh-button:hover {
      background: rgba(255,255,255,1);
    }

    /* Leaflet custom marker styling */
    .custom-leaflet-marker {
      background: transparent !important;
      border: none !important;
    }

    /* Modern popup styling */
    .custom-popup {
      background: white;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      min-width: 200px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }

    .custom-popup-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .custom-popup-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid #e0e0e0;
    }

    .custom-popup-info {
      flex: 1;
    }

    .custom-popup-name {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      margin: 0 0 4px 0;
    }

    .custom-popup-state {
      font-size: 13px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .custom-popup-state-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .custom-popup-speed {
      font-size: 13px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
    }

    .custom-popup-activity {
      font-size: 13px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
    }

    /* Leaflet popup customization */
    .leaflet-popup-content-wrapper {
      padding: 0;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .leaflet-popup-content {
      margin: 0;
      min-width: 200px;
    }

    .leaflet-popup-tip {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Google Maps InfoWindow styling */
    .gm-style .gm-style-iw-c {
      padding: 0 !important;
      border-radius: 12px !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
    }

    .gm-style .gm-style-iw-d {
      overflow: hidden !important;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="refresh-button" title="Reset map to initial view">
    <i class="mdi mdi-fit-to-screen"></i> Recenter
  </button>

<script>
// Parse URL parameters for configuration
const urlParams = new URLSearchParams(window.location.search);
const MAP_PROVIDER = urlParams.get('provider') || 'osm'; // 'osm' or 'google'
const GOOGLE_API_KEY = urlParams.get('apikey') || 'YOUR_API_KEY_HERE';
const DEFAULT_ZOOM = parseInt(urlParams.get('zoom')) || 13;
const MAP_TYPE = urlParams.get('maptype') || 'hybrid';
const MODE = urlParams.get('mode') || 'proxy';
const DEBUG = urlParams.get('debug') === '1';
const TILT_ZOOM_THRESHOLD = parseInt(urlParams.get('tiltzoom')) || 18; // Zoom level to enable tilt
const MARKER_BORDER_RADIUS = decodeURIComponent(urlParams.get('marker_radius') || '50%');
const BADGE_BORDER_RADIUS = decodeURIComponent(urlParams.get('badge_radius') || '50%');
const MARKER_SIZE_PARAM = urlParams.get('marker_size') || 'medium';

// Marker size presets
const MARKER_SIZES = {
  small: {
    marker: 36,
    badge: 15,
    popupOffset: -52
  },
  medium: {
    marker: 48,
    badge: 20,
    popupOffset: -68
  },
  large: {
    marker: 64,
    badge: 24,
    popupOffset: -88
  }
};

// Get selected marker size with fallback to medium
let selectedMarkerSize = MARKER_SIZES[MARKER_SIZE_PARAM] || MARKER_SIZES.medium;

// Apply CSS custom properties for dynamic sizing
document.documentElement.style.setProperty('--marker-size', `${selectedMarkerSize.marker}px`);
document.documentElement.style.setProperty('--badge-size', `${selectedMarkerSize.badge}px`);
document.documentElement.style.setProperty('--popup-offset', `${selectedMarkerSize.popupOffset}px`);
document.documentElement.style.setProperty('--marker-height', `${selectedMarkerSize.marker + 14}px`); // +14 for pointer

// Apply CSS variables for border radius and sizing
const styleSheet = document.getElementById('dynamic-styles');

// Set CSS variables on document root
document.documentElement.style.setProperty('--marker-radius', MARKER_BORDER_RADIUS);
document.documentElement.style.setProperty('--badge-radius', BADGE_BORDER_RADIUS);
document.documentElement.style.setProperty('--marker-size', `${selectedMarkerSize.marker}px`);
document.documentElement.style.setProperty('--badge-size', `${selectedMarkerSize.badge}px`);
document.documentElement.style.setProperty('--popup-offset', `${selectedMarkerSize.popupOffset}px`);
document.documentElement.style.setProperty('--marker-height', `${selectedMarkerSize.marker + 14}px`);

// Add static CSS rules that use CSS variables (only if stylesheet is available)
if (styleSheet && styleSheet.sheet) {
  // Add static sizing and radius rules that use CSS variables
  styleSheet.sheet.insertRule(`.custom-marker-wrapper { width: var(--marker-size); height: calc(var(--marker-size) + 14px); }`, styleSheet.sheet.cssRules.length);
  styleSheet.sheet.insertRule(`.custom-marker-profile-wrapper { width: var(--marker-size); height: var(--marker-height); }`, styleSheet.sheet.cssRules.length);
  styleSheet.sheet.insertRule(`.custom-marker-image-container { width: var(--marker-size); height: var(--marker-height); }`, styleSheet.sheet.cssRules.length);
  styleSheet.sheet.insertRule(`.custom-marker-image { width: var(--marker-size); height: var(--marker-size); border-radius: var(--marker-radius); }`, styleSheet.sheet.cssRules.length);
  styleSheet.sheet.insertRule(`.custom-marker-badge { width: var(--badge-size); height: var(--badge-size); border-radius: var(--badge-radius); font-size: calc(var(--badge-size) * 0.6); }`, styleSheet.sheet.cssRules.length);
}

// Parse entities configuration
const entitiesParam = urlParams.get('entities') || '';
const ENTITIES = entitiesParam.split(',').map(e => {
  const parts = e.trim().split(':');
  return {
    person: parts[0],
    activity: parts[1] || null
  };
}).filter(e => e.person);

// Parse zones configuration (zones only have colors now, no icons)
const zonesParam = urlParams.get('zones') || '';
const ZONES = {};
if (zonesParam) {
  zonesParam.split(',').forEach(zone => {
    const [state, color] = zone.split(':');
    if (state && color) {
      ZONES[state] = { color: decodeURIComponent(color) };
    }
  });
}

// Default zones if not configured
if (Object.keys(ZONES).length === 0) {
  ZONES.home = { color: '#cef595' };
  ZONES.not_home = { color: '#757575' };
}

// Parse activities configuration
const activitiesParam = urlParams.get('activities') || '';
const ACTIVITIES = {};
if (activitiesParam) {
  activitiesParam.split(',').forEach(activity => {
    const [state, icon, color] = activity.split(':');
    if (state && icon && color) {
      // Convert icon from 'mdi:icon-name' to 'mdi-icon-name' format
      const iconClass = icon.replace(':', '-');
      ACTIVITIES[state] = { icon: iconClass, color: decodeURIComponent(color) };
    }
  });
}

// Default activities if not configured (activities always have white icons on configurable backgrounds)
// By default, use black background if no activities are configured
if (Object.keys(ACTIVITIES).length === 0) {
  ACTIVITIES.unknown = { icon: 'mdi-human-male', color: '#000000' };
}

let map;
let markers = {};
let entityData = {};
let lastUpdate = null;
let updateCount = 0;
let initialViewSet = false;
let isOSM = MAP_PROVIDER === 'osm';
let currentPopup = null; // Track currently open popup

// OpenStreetMap initialization
function initOSM() {
  try {
    map = L.map('map').setView([0, 0], DEFAULT_ZOOM);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    console.log('OpenStreetMap initialized');

    // Signal that map is ready
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'iframe-ready' }, '*');
    }
  } catch (error) {
    console.error('Error initializing OpenStreetMap:', error);
  }
}

// Google Maps initialization
function initGoogleMaps() {
  try {
    // Determine map type ID
    let mapTypeId;
    switch(MAP_TYPE.toLowerCase()) {
      case 'satellite':
        mapTypeId = google.maps.MapTypeId.SATELLITE;
        break;
      case 'hybrid':
        mapTypeId = google.maps.MapTypeId.HYBRID;
        break;
      case 'terrain':
        mapTypeId = google.maps.MapTypeId.TERRAIN;
        break;
      case 'roadmap':
      default:
        mapTypeId = google.maps.MapTypeId.ROADMAP;
        break;
    }

    map = new google.maps.Map(document.getElementById('map'), {
      center: { lat: 0, lng: 0 },
      zoom: DEFAULT_ZOOM,
      mapTypeId: mapTypeId,
      mapTypeControl: false,
      mapTypeControlOptions: {
        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
        position: google.maps.ControlPosition.TOP_RIGHT
      },
      zoomControl: false,
      zoomControlOptions: {
        position: google.maps.ControlPosition.RIGHT_CENTER
      },
      streetViewControl: true,
      fullscreenControl: false,
      // Enable rotation controls
      rotateControl: false,
      rotateControlOptions: {
        position: google.maps.ControlPosition.RIGHT_CENTER
      },
      // Smooth animations
      gestureHandling: 'greedy',
      // Allow tilt
      tilt: 0 // Start flat, will tilt when zoomed in
    });

    // Listen for zoom changes to enable/disable tilt
    map.addListener('zoom_changed', () => {
      const currentZoom = map.getZoom();
      const currentTilt = map.getTilt();

      // Enable 45-degree tilt when zoomed in beyond threshold
      if (currentZoom >= TILT_ZOOM_THRESHOLD && currentTilt === 0) {
        map.setTilt(45);
        console.log(`Tilt enabled at zoom level ${currentZoom}`);
      }
      // Disable tilt when zooming out
      else if (currentZoom < TILT_ZOOM_THRESHOLD && currentTilt === 45) {
        map.setTilt(0);
        console.log(`Tilt disabled at zoom level ${currentZoom}`);
      }
    });

    console.log('Google Maps initialized with tilt support');

  } catch (error) {
    console.error('Error initializing map:', error);
  }
}

// Unified init function
function initMap() {
  if (isOSM) {
    initOSM();
  } else {
    initGoogleMaps();
  }
}

function createMarkerHTML(personState, activityState, pictureUrl) {
  const zoneConfig = ZONES[personState] || ZONES.not_home || { color: '#757575' };
  const activityConfig = ACTIVITIES[activityState] || ACTIVITIES.unknown || { icon: 'mdi-human-male', color: '#000000' };

  return `
    <div class="custom-marker-wrapper">
      <div class="custom-marker-profile-wrapper">
        <div class="custom-marker-image-container" style="--border-color: ${zoneConfig.color};">
          <img
            src="${pictureUrl}"
            class="custom-marker-image"
            style="border: 3px solid ${zoneConfig.color}"
            onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2248%22 height=%2248%22><circle cx=%2224%22 cy=%2224%22 r=%2220%22 fill=%22%23cccccc%22/></svg>'">
        </div>
        <div class="custom-marker-badge" style="background: ${activityConfig.color}; color: white;">
          <i class="mdi ${activityConfig.icon}"></i>
        </div>
      </div>
      <div class="custom-marker-position-circle" style="background: #76D4C3; border: 2px solid ${zoneConfig.color};"></div>
    </div>
  `;
}

function createPopupHTML(friendlyName, personState, pictureUrl, zoneColor, speedData, activityState) {
  const stateLabel = personState.charAt(0).toUpperCase() + personState.slice(1).replace(/_/g, ' ');
  
  // Get activity display info from ACTIVITIES config
  const activityConfig = ACTIVITIES[activityState] || ACTIVITIES.unknown || { icon: 'mdi-human-male', color: '#000000', name: 'Unknown' };
  
  // Create speed display HTML if speed data is available
  const speedHtml = speedData && speedData.speed_kmh !== null ? `
    <div class="custom-popup-speed">
      <i class="mdi mdi-speedometer" style="color: #666; margin-right: 4px;"></i>
      ${speedData.speed_kmh.toFixed(1)} km/h
    </div>
  ` : '';
  
  // Create activity display HTML
  const activityHtml = `
    <div class="custom-popup-activity">
      <i class="mdi ${activityConfig.icon}" style="color: ${activityConfig.color}; margin-right: 4px;"></i>
      ${activityConfig.name}
    </div>
  `;

  return `
    <div class="custom-popup">
      <div class="custom-popup-header">
        <img
          src="${pictureUrl}"
          class="custom-popup-avatar"
          onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2248%22 height=%2248%22><circle cx=%2224%22 cy=%2224%22 r=%2220%22 fill=%22%23cccccc%22/></svg>'">
        <div class="custom-popup-info">
          <h3 class="custom-popup-name">${friendlyName}</h3>
          <div class="custom-popup-state">
            <span class="custom-popup-state-icon" style="background: ${zoneColor}"></span>
            ${stateLabel}
          </div>
          ${speedHtml}
          ${activityHtml}
        </div>
      </div>
    </div>
  `;
}

function updateMarker(entityId, data) {
  const lat = data.attributes.latitude;
  const lon = data.attributes.longitude;
  const personState = data.state;
  const activityState = data.activity || 'unknown';
  const pictureUrl = data.attributes.entity_picture || '';

  if (!lat || !lon || isNaN(lat) || isNaN(lon)) {
    console.warn(`Invalid GPS coordinates for ${entityId}:`, lat, lon);
    return false;
  }

  try {
    if (isOSM) {
      return updateMarkerOSM(entityId, data, lat, lon, personState, activityState, pictureUrl);
    } else {
      return updateMarkerGoogle(entityId, data, lat, lon, personState, activityState, pictureUrl);
    }
  } catch (error) {
    console.error(`Error updating marker for ${entityId}:`, error);
    return false;
  }
}

// OpenStreetMap marker update
function updateMarkerOSM(entityId, data, lat, lon, personState, activityState, pictureUrl) {
  const friendlyName = data.attributes.friendly_name || entityId;
  const zoneConfig = ZONES[personState] || ZONES.not_home || { color: '#757575' };
  const speedData = data.speed || null;
  
  // Get dynamic marker dimensions
  const markerSize = selectedMarkerSize.marker;
  const markerHeight = markerSize + 14;
  const markerAnchor = Math.floor(markerSize / 2);
  const popupOffset = selectedMarkerSize.popupOffset;

  let marker = markers[entityId];
  const wasPopupOpen = marker && marker.isPopupOpen();

  if (marker) {
    // Update existing marker
    marker.setLatLng([lat, lon]);

    // Update popup content
    const popupContent = createPopupHTML(friendlyName, personState, pictureUrl, zoneConfig.color, speedData, activityState);
    marker.setPopupContent(popupContent);

    // Update icon HTML
    const iconHtml = createMarkerHTML(personState, activityState, pictureUrl);
    marker.setIcon(L.divIcon({
      className: 'custom-leaflet-marker',
      html: iconHtml,
      iconSize: [markerSize, markerHeight],
      iconAnchor: [markerAnchor, markerHeight],
      popupAnchor: [0, popupOffset]
    }));
    
    // If popup was open, keep it open (setLatLng automatically updates popup position)
  } else {
    // Create new marker
    const iconHtml = createMarkerHTML(personState, activityState, pictureUrl);
    const icon = L.divIcon({
      className: 'custom-leaflet-marker',
      html: iconHtml,
      iconSize: [markerSize, markerHeight],
      iconAnchor: [markerAnchor, markerHeight],
      popupAnchor: [0, popupOffset]
    });

    marker = L.marker([lat, lon], { icon: icon }).addTo(map);

    const popupContent = createPopupHTML(friendlyName, personState, pictureUrl, zoneConfig.color, speedData, activityState);
    marker.bindPopup(popupContent);

    // Close other popups when this one opens
    marker.on('popupopen', function() {
      if (currentPopup && currentPopup !== marker) {
        currentPopup.closePopup();
      }
      currentPopup = marker;
    });

    markers[entityId] = marker;
  }

  return true;
}

// Google Maps marker update
function updateMarkerGoogle(entityId, data, lat, lon, personState, activityState, pictureUrl) {
  const position = { lat: lat, lng: lon };
  const friendlyName = data.attributes.friendly_name || entityId;
  const zoneConfig = ZONES[personState] || ZONES.not_home || { color: '#757575' };
  const speedData = data.speed || null;

  if (markers[entityId]) {
    // Update existing marker
    const marker = markers[entityId];
    const wasPopupOpen = marker.infoWindow && marker.infoWindow.getMap();
    
    marker.setPosition(position);

    // Update the custom overlay content
    const overlayDiv = marker.overlayDiv;
    if (overlayDiv) {
      overlayDiv.innerHTML = createMarkerHTML(personState, activityState, pictureUrl);
    }

    // Update info window content and position
    if (marker.infoWindow) {
      marker.infoWindow.setContent(createPopupHTML(friendlyName, personState, pictureUrl, zoneConfig.color, speedData, activityState));
      marker.infoWindow.setPosition(position);
    }
  } else {
    // Create custom HTML overlay
    class CustomMarker extends google.maps.OverlayView {
      constructor(position, html, title) {
        super();
        this.position = position;
        this.html = html;
        this.title = title;
        this.div = null;
      }

      onAdd() {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.cursor = 'pointer';
        div.innerHTML = this.html;
        div.title = this.title;

        // Add click event for info window
        div.addEventListener('click', () => {
          // Close currently open popup
          if (currentPopup && currentPopup !== this.infoWindow) {
            currentPopup.close();
          }

          if (this.infoWindow) {
            this.infoWindow.open(this.getMap());
            currentPopup = this.infoWindow;
          }
        });

        this.div = div;
        const panes = this.getPanes();
        panes.overlayMouseTarget.appendChild(div);
      }

      draw() {
        const overlayProjection = this.getProjection();
        const pos = overlayProjection.fromLatLngToDivPixel(
          new google.maps.LatLng(this.position.lat, this.position.lng)
        );

        const div = this.div;
        const markerSize = selectedMarkerSize.marker;
        const markerHeight = markerSize + 14;
        const markerAnchor = Math.floor(markerSize / 2);
        
        div.style.left = (pos.x - markerAnchor) + 'px'; // Center horizontally
        div.style.top = (pos.y - markerHeight) + 'px'; // Position above point
      }

      onRemove() {
        if (this.div) {
          this.div.parentNode.removeChild(this.div);
          this.div = null;
        }
      }

      setPosition(newPosition) {
        this.position = newPosition;
        this.draw();
      }

      updateContent(html) {
        if (this.div) {
          this.div.innerHTML = html;
        }
      }
    }

    const marker = new CustomMarker(
      position,
      createMarkerHTML(personState, activityState, pictureUrl),
      friendlyName
    );

    marker.setMap(map);

    // Create info window with modern popup
    const infoWindow = new google.maps.InfoWindow({
      content: createPopupHTML(friendlyName, personState, pictureUrl, zoneConfig.color, speedData, activityState),
      position: position,
      pixelOffset: new google.maps.Size(0, selectedMarkerSize.popupOffset)
    });

    marker.infoWindow = infoWindow;
    marker.overlayDiv = marker.div;
    markers[entityId] = marker;
  }

  return true;
}

function fitMapToMarkers() {
  if (Object.keys(markers).length === 0) {
    return;
  }

  try {
    if (isOSM) {
      // OpenStreetMap (Leaflet)
      if (Object.keys(markers).length === 1) {
        const marker = Object.values(markers)[0];
        map.setView(marker.getLatLng(), DEFAULT_ZOOM);
      } else {
        const group = L.featureGroup(Object.values(markers));
        map.fitBounds(group.getBounds(), { padding: [50, 50] });
      }
    } else {
      // Google Maps
      if (Object.keys(markers).length === 1) {
        const marker = Object.values(markers)[0];
        map.setCenter(marker.position);
        map.setZoom(DEFAULT_ZOOM);
      } else {
        const bounds = new google.maps.LatLngBounds();
        Object.values(markers).forEach(marker => {
          bounds.extend(marker.position);
        });
        map.fitBounds(bounds, { padding: 50 });
      }
    }
  } catch (error) {
    console.error('Error fitting map to markers:', error);
  }
}

function updateAllMarkers() {
  let successCount = 0;
  let errorCount = 0;
  
  for (const [entityId, data] of Object.entries(entityData)) {
    if (updateMarker(entityId, data)) {
      successCount++;
    } else {
      errorCount++;
    }
  }
  
  if (!initialViewSet && Object.keys(markers).length > 0) {
    fitMapToMarkers();
    initialViewSet = true;
  }
}

// Load Google Maps API only if needed
function loadGoogleMapsAPI() {
  const script = document.createElement('script');
  script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&loading=async&callback=initMap`;
  script.async = true;
  script.defer = true;
  script.onerror = () => {
    console.error('Failed to load Google Maps API');
  };
  document.head.appendChild(script);
}

// Make initMap global for callback
window.initMap = initMap;

// Load appropriate map provider
if (isOSM) {
  // OpenStreetMap - Leaflet is already loaded, just initialize
  initMap();
} else {
  // Google Maps - need to load API first
  loadGoogleMapsAPI();
}

// Set up refresh button
document.getElementById('refresh-button').addEventListener('click', fitMapToMarkers);

// Listen for entity data from parent
window.addEventListener('message', (event) => {
  if (!event.data || !event.data.type) {
    return;
  }

  if (event.data.type === 'entity-update') {
    const newData = event.data.data || {};
    const hasData = Object.keys(newData).length > 0;

    if (hasData) {
      entityData = newData;
      lastUpdate = event.data.timestamp;
      updateCount++;

      updateAllMarkers();

      if (window.parent !== window) {
        window.parent.postMessage({ type: 'data-received' }, '*');
      }
    }
  } else if (event.data.type === 'config-update') {
    // Handle dynamic config updates (zones, activities, border radius)
    if (event.data.zones) {
      Object.keys(ZONES).forEach(key => delete ZONES[key]);
      Object.assign(ZONES, event.data.zones);
      console.log('Zones updated:', ZONES);
    }

    if (event.data.activities) {
      Object.keys(ACTIVITIES).forEach(key => delete ACTIVITIES[key]);
      // Convert icon format from 'mdi:icon-name' to 'mdi-icon-name'
      const convertedActivities = {};
      Object.entries(event.data.activities).forEach(([state, config]) => {
        convertedActivities[state] = {
          ...config,
          icon: config.icon ? config.icon.replace(':', '-') : config.icon
        };
      });
      Object.assign(ACTIVITIES, convertedActivities);
      console.log('Activities updated:', ACTIVITIES);
    }

    if (event.data.marker_border_radius || event.data.badge_border_radius) {
      // Update border radius CSS variables
      if (event.data.marker_border_radius) {
        document.documentElement.style.setProperty('--marker-radius', event.data.marker_border_radius);
      }
      if (event.data.badge_border_radius) {
        document.documentElement.style.setProperty('--badge-radius', event.data.badge_border_radius);
      }
      
      const markerRadius = event.data.marker_border_radius || getComputedStyle(document.documentElement).getPropertyValue('--marker-radius');
      const badgeRadius = event.data.badge_border_radius || getComputedStyle(document.documentElement).getPropertyValue('--badge-radius');
      console.log('Border radius updated:', markerRadius, badgeRadius);
    }

    if (event.data.marker_size && MARKER_SIZES[event.data.marker_size]) {
      // Update marker size dynamically
      const newSize = MARKER_SIZES[event.data.marker_size];
      selectedMarkerSize.marker = newSize.marker;
      selectedMarkerSize.badge = newSize.badge;
      selectedMarkerSize.popupOffset = newSize.popupOffset;
      
      // Update CSS custom properties
      document.documentElement.style.setProperty('--marker-size', `${newSize.marker}px`);
      document.documentElement.style.setProperty('--badge-size', `${newSize.badge}px`);
      document.documentElement.style.setProperty('--popup-offset', `${newSize.popupOffset}px`);
      document.documentElement.style.setProperty('--marker-height', `${newSize.marker + 14}px`);
      
      console.log('Marker size updated to:', event.data.marker_size);
    }

    // Re-render all markers with new config
    updateAllMarkers();

    if (window.parent !== window) {
      window.parent.postMessage({ type: 'config-received' }, '*');
    }
  }
});

// Send ready signals to parent
function sendReadySignal() {
  if (window.parent !== window) {
    window.parent.postMessage({ type: 'iframe-ready' }, '*');
  }
}

sendReadySignal();
setTimeout(sendReadySignal, 500);
setTimeout(sendReadySignal, 1500);
setTimeout(sendReadySignal, 3000);

// Request data periodically if not receiving updates
let requestCount = 0;
setInterval(() => {
  const now = Date.now();
  const timeSinceUpdate = lastUpdate ? (now - lastUpdate) / 1000 : Infinity;
  
  if (timeSinceUpdate > 20) {
    requestCount++;
    
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'request-data' }, '*');
      window.parent.postMessage({ type: 'iframe-ready' }, '*');
    }
  }
}, 10000);
</script>
</body>
</html>
